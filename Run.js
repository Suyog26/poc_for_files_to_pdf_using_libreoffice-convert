// Import required modules
const express = require('express');
const axios = require('axios');
const temp = require('temp');
const libre = require('libreoffice-convert');
const fs = require('fs');
const xlsx = require('xlsx');
const pdf = require('pdf-parse');
const puppeteer = require('puppeteer');
const path = require('path');
const os = require('os');
const myURL = require('node:url');

// Create Express app
const app = express();
const port = 3000;

app.use(express.json())
// Output folder for PDFs
const outputFolder = 'C:/Users/user/Desktop/poc/finalpoc/download';

// Function to get the content type of a URL
async function getContentType(url) {
    try {
        const response = await axios.head(url);
        return response.headers['content-type'];
    } catch (error) {
        throw new Error(`Error getting content type: ${error.message}`);
    }
}

// Function to download the .docx file with retry
async function downloadDocxWithRetry(url, outputFolder, callback, retries = 3, delay = 1000) {
    let attempts = 0;

    async function tryDownload() {
        try {
            const response = await axios.get(url, { responseType: 'arraybuffer' });
            const fileName = url.split('/').pop();
            const tempFilePath = temp.path({ suffix: `_${fileName}` });
            fs.writeFileSync(tempFilePath, Buffer.from(response.data));
            callback(null, tempFilePath);
        } catch (error) {
            attempts++;
            if (attempts < retries) {
                console.log(`Retry ${attempts} failed. Retrying in ${delay / 1000} seconds...`);
                setTimeout(tryDownload, delay);
            } else {
                console.error(`Error downloading file: ${error.message}`);
                callback(error);
            }
        }
    }

    tryDownload();
}

// Convert function
function convertToPDF(inputPath, outputPath, callback) {
    const file = fs.readFileSync(inputPath);

    // Convert the file
    libre.convert(file, '.pdf', undefined, (err, done) => {
        if (err) {
            console.log(`Error converting file: ${err}`);
            callback(err);
        } else {
            // Write the converted file to the output path
            fs.writeFileSync(outputPath, done);

            // Delete the temporary .docx file
            fs.unlinkSync(inputPath);
            console.log('Downloaded .docx file deleted.');

            console.log(`File converted successfully! Output file: ${outputPath}`);
            callback(null);
        }
    });
}

// Function to extract text from PDF
async function extractTextFromPDF(pdfPath) {
    return new Promise((resolve, reject) => {
        const dataBuffer = fs.readFileSync(pdfPath);

        pdf(dataBuffer)
            .then(data => {
                const text = data.text;
                resolve(text);
            })
            .catch(error => {
                reject(error);
            });
    });
}

// Function to generate PDF from a web URL

async function generatePDF(url) {
    const browser = await puppeteer.launch({headless: true});
    const page = await browser.newPage();

    try {
        await page.goto("https://www.web2pdfconvert.com/");
        await page.waitForSelector(".js-url-input");

        await page.type(".js-url-input", url);
        await page.click(".convert-icon");

        await new Promise((r) => setTimeout(r, 15000));

        const downloadFile = ".result-download";
        await page.waitForSelector(downloadFile);
        await page.click(downloadFile);

        await new Promise((r) => setTimeout(r, 8000));

        let dynamicDownloadsPath;
        if (os.platform() === "win32") {
            dynamicDownloadsPath = path.join(os.homedir(), "Downloads");
        } else if (os.platform() === "darwin") {
            dynamicDownloadsPath = path.join(os.homedir(), "Downloads");
        } else {
            dynamicDownloadsPath = path.join(os.homedir(), "Downloads");
        }

        // Creating file name as generated by the third party to move the file to the desired location
        const parsedURL = myURL.parse(url);
        let tempUrl = url.split(`${parsedURL.protocol}//`)[1];
        tempUrl = tempUrl.replace(/[^a-zA-Z0-9]/g, "-");
        tempUrl = tempUrl.slice(0, 80);

        // Moving file to the desired location
        let filePath = path.join(dynamicDownloadsPath, tempUrl);
        filePath += ".pdf";
        let targetPath = path.join(__dirname, ".", "output3.pdf");
        await fs.promises.copyFile(filePath, targetPath);
        await fs.promises.unlink(filePath);

        return tempUrl;
    } catch (error) {
        console.error("Error during weburl conversion:", error);

        // Provide the downloaded PDF path and URL link in case of an error
        return { error: error.message, pdfPath: "", url: url };
    } finally {
        await browser.close();
    }
}




// API endpoint to process URLs
app.post('/process-url', async (req, res) => {
    const { url } = req.body;

    try {
        // Get the content type of the URL
        const contentType = await getContentType(url);

        // Check the content type and decide the conversion method
        if (contentType.includes('text/html')) {
            // If content type is text/html, use weburl conversion method
            await generatePDF(url);

            // Extract text from the generated PDF
            const outputPath = path.join(__dirname, 'output3.pdf');
            const text = await extractTextFromPDF(outputPath);

            res.status(200).json({
                text,
                pdfPath: outputPath,
                url,
            });
        } else {
            // If content type is not text/html, use libreoffice conversion method
            // Download .docx file
            downloadDocxWithRetry(url, outputFolder, async (err, tempDocxPath) => {
                if (err) {
                    return res.status(500).json({ error: `Download failed: ${err.message}` });
                }

                // Convert .docx to PDF
                const outputFileName = `output.pdf`;
                const outputPath = `${outputFolder}/${outputFileName}`;

                convertToPDF(tempDocxPath, outputPath, async (conversionError) => {
                    if (conversionError) {
                        return res.status(500).json({ error: `Conversion failed: ${conversionError.message}` });
                    }

                    // Extract text from PDF
                    try {
                        const text = await extractTextFromPDF(outputPath);
                        res.status(200).json({
                            text,
                            pdfPath: outputPath,
                            url,
                        });
                    } catch (extractionError) {
                        res.status(500).json({ error: `Text extraction failed: ${extractionError.message}` });
                    }
                });
            });
        }
    } catch (error) {
        res.status(500).json({ error: error.message,url});
    }
});

// Start the server
app.listen(port, () => {
    console.log(`Server is running on port ${port}`);
});


//  "error": "Node is either not clickable or not an Element"